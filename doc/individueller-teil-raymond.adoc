:sectnums:
:sectnumlevels: 5
== Individueller Teil Raymond Denis Vladu

=== Einleitung

Der individuelle Teil gliedert sich in drei Teilbereiche.

Der erste Teil des individuellen Teils befasst sich mit der Evaluierung bewährter Technologie-Stacks, die die Anforderungen des Projekts „EduCluster“ erfüllen. Darin werden verschiedene Technologie-Stacks bewertet und der am besten geeignete Stapel ermittelt.

Folglich wird im zweiten Abschnitt die technische Umsetzung erklärt. Dabei wird auf den Aufbau des Grundgerüsts der Applikation gezielt. Es werden die einzelnen Schritte des Aufbaus und der Konfiguration erläutert und mit konkreten Beispielen ergänzt.

Zu guter Letzt wird im dritten Teil eine kurze Zusammenfassung der erreichten Ziele, die Reflexion der eigenen Arbeit sowie eine Zukunftsaussicht des vorgeschlagenen Lösungsansatzes erarbeitet.

=== Evaluierung der Technologie-Stacks
Eine Evaluierung der verschiedenen potentiellen Technologie-Stacks für die Entwicklung der Webapplikation „EduCluster“ bedeutet eine Analyse und Bewertung der zur Verfügung stehenden Möglichkeiten. Zur Erfüllung dieser Aufgabe werden die bekanntesten Stacks ausgesucht, damit die Qualität der gruppierten Technologien nicht nur theoretisch, sondern auch praktisch bewiesen werden kann.

Im Laufe dieses Abschnitts werden die ausgewählten Stacks vorgestellt und anhand von Beurteilungskriterien bewertet. Die Bewertung wird sich an den Anforderungen richten und anschließend einen Sieger ankündigen, der für die technische Umsetzung benutzt werden soll.

==== Stakeholder der Evaluierung
Bei der Evaluierung eines Technologie-Stacks sollen die Interessen verschiedener Stakeholder beachtet werden.

TODO: Erweitern

==== Zieldefinition
Das Ziel dieser Evaluierung ist die Wahl des richtigen Technologie-Stacks für die Webapplikation „EduCluster“ unter Berücksichtigung der Anforderungen des Projekts. Es wird darauf hingewiesen, dass die Ermittlung einer geeigneten Datenbank nicht inkludiert wird, da dieser Teil von Lara Kammerer übernommen wird.

===== Was ist ein Technologie-Stack?
Ein Technologie-Stack ist ein Stapel von Technologien, der sich aus Frameworks und Libraries zusammensetzt. Darin können entweder alle oder nur die auschlaggebendsten Technologien aufgefasst werden, die in dem Projekt ihren Einsatz finden. Da ersteres den vorgesehenen Zeitrahmen sprengen würde, wird die zweite Variante aufgenommen.

Der Stapel kann konzeptionell in vier Teilen gespalten werden:

•	Frontend, worin der GUI-Entwurf und die clientseitige Logik implementiert wird
•	Backend, in dem die serverseitige Logik und die Anbindung an die Datenbank implementiert wird
•	API, die eine Verbindung zwischen Frontend und Backend aufbaut
•	Datenbank, wo die relevanten Daten gespeichert und abgerufen werden

Wie bereits erwähnt wird die Datenbankschicht aus dieser Evaluierung ausgeschlossen. Somit liegt der Fokus auf den Frontend, den Backend und die Programmierungsschnittstelle.

===== Warum wird ein Technologie-Stack benötigt?
Um die Gestaltung einer umfangreichen Webapplikation wie „EduCluster“ sicherzustellen und dabei ein qualitatives Ergebnis liefern zu können hat sich das Projektteam dazu entschieden, die mit dieser Aufgabe verbundenen Komplexität durch Einsatz bewährter Technologien möglichst viel zu reduzieren.

Der Einsatz mehrerer Technologien und deren Auffassung in Form eines Technologiestapels hat sich vor allem durch den Einfluss großer Technologie-Konzernen wie Meta (vormals Facebook), Netflix und Amazon als Standard durchgesetzt. Um den Umsetzungserfolg gewährleisten zu können ist es strategisch sinnvoll, diesem Trend zu folgen.

===== Anforderungen an den Technologie-Stack
Der Technologiestapel muss in erster Linie Technologien enthalten, mit denen die Entwickler bereits Erfahrung gesammelt haben. Es ist natürlich unmlöglich einen Stapel zu finden, in dem alle Technologien von allen Entwicklern bereits genutzt wurden. Allerdings soll im Allgemeinen auf Technologien verzichtet werden, mit denen keiner der Entwickler Erfahrung hat, da sonst ein großer Schnitt der zur Verfügung stehenden Zeit unproduktiv genutzt wird.

Außerdem sollen nur die Technologien ausgewählt werden, die den Entwicklungsaufwand am meisten reduzieren und den schnellsten Entwicklungsprozess fördern. Hier wird nochmals darauf hingewiesen, dass eine effiziente Nutzung der verfügbaren Zeit der wichtigste Faktor ist, um ein Projekt der Größe von EduCluster erfolgreich abschließen zu können.

Die laufende Innovation im Bereich der Webentwicklung bewirkt eine ständige Änderung der Technologie-Trends. Dies bedeutet, dass viele Technologien im Laufe der Zeit von besseren Varianten ersetzt werden. Um zu verhindern, dass sich die Applikation EduCluster von Technologien abhängig macht, die in kürzester Zeit durch neue Stars ersetzt werden, soll auf eine möglichst moderne Austattung gezielt werden.

Um unnötige Bugs auszuschließen und die Entwicklererfahrung möglichst gut zu gestalten ist es sinnvoll auf eine vollständige Typensicherheit der Aplikation zu zielen. Typensicherheit ist ein wesentlicher Schutz vor Programmfehlern, die von dem Kompiler vor der Ausführung des Programms bereits gefangen werden.

Zu guter Letzt soll auf die Beliebtheit der jeweiligen Technologien geachtet werden, um die sicherste Wette auf einen dauerhaften Technologiestapel zu setzen.

==== Ermittlung der möglichen Frontend-Technologien
Dieser Abschnitt umfasst die drei bekanntesten Frontend-Technologien stand 2022. footnote:[Vgl. https://technostacks.com/blog/best-frontend-frameworks/, abgerufen am 29.10.2022]

===== React.js
React ist eine deklarative, komponentenbasierte JavaScript Bibliothek für den Frontend. Es wurde im Jahr 2013 mit der Open-Source-Lizenz von dem damaligen Unternehmen „Facebook“ veröffentlicht.

Abgesehen davon, dass sie die bekannteste JavaScript Bibliothek ist, bietet React auch eine breite Palette an Features.

Zum einen besitzt sie ein virtuelles DOM footnote:[Vgl. https://reactjs.org/docs/faq-internals.html, abgerufen am 29.10.2022], das zwischengespeichert und mit dem tatsächlichen DOM synchronisiert wird, um nur diejenigen Komponenten zu rendern, die sich geändert haben. Damit erzielt React eine Erhöhung der Performanz und ermöglicht eine deklarative API. Das bedeutet, dass der Entwickler den erwünschten UI-Zustand definieren kann und React führt im Hintergrund die benötigte Arbeit durch, damit das DOM diesen Zustand entspricht.

Obwohl das Programmieren mit React sich an die Prinzipien des deklarativen Paradigmas hält, ermöglicht die Bibliothek beim Erstellen von Komponenten eine Wahl wischen funktionelle und klassenbasierte Komponenten. Damit kann sich der Entwickler für eine bestimmte JSX-basierte Syntax entscheiden.

Zu guter Letzt gibt es zumindest für funktionelle Komponente die Möglichkeit, sogenannte „Hooks“ footnote:[Vgl. https://reactjs.org/docs/hooks-intro.html, abgerufen am 29.10.2022] selbst zu definieren oder von einem Package Manager zu installieren. Diese Konstrukte ermöglichen einen direkten Zugriff auf Zustands- und Lebenszyklus-Features in Form einer Funktion.

===== Vue.js
Vue ist ein JavaScript Framework, das häufig als Alternative zu React vorgestellt wird. Jedoch wurde Vue nicht von einem Internet-Giganten, sondern einem gewöhnlichen Entwickler entwickelt und schließlich im Jahr 2014 veröffentlicht.

Vue ist ebenso wie React auf Komponenten und deklarativem Rendering basiert, und setzt ebenfalls auf die Strategie des virtuellen DOMs. Jedoch ist Vue in einer Hinsicht React überlegen. Es besitzt eine sogenannte „two-way data binding“, wodurch eine sofortige Synchronisierung zwischen UI und Datenmodell sicherstellt wird.

Ein weiteres Merkmal von Vue sind die „directives“ footnote:[Vgl. https://vuejs.org/api/built-in-directives.html, abgerufen am 29.10.2022]. Diese sind Anweisungen, die in der HTML-Template eingebettet werden können und bestimmte Verhalten kontrollieren oder auslösen.

===== Angular
Angular ist ein auf TypeScript basierendes Framework, das von Google im Jahr 2016 veröffentlicht wurde. Angular ist zwar weniger beliebt wie React und Vue footnote:[Vgl. https://2022.stateofjs.com/en-US/libraries/front-end-frameworks/, abgerufen am 11.01.2023], aber es wird dennoch in vielen Unternehmen eingesetzt, vor allem in Österreich footnote:[Vgl. https://www.stepstone.at/jobs/angular mit Treffer für React.js und Vue.js, aufgerufen am 29.10.2022]. Dafür gibt es gute Gründe.

Angular hat ein System entwickelt, das ein hierarchisches „Dependency Injection“ Konzept beinhaltet. Dank dieses Features können Klassen mit Angular-Decorators ihre Abhängigkeiten konfigurieren. Unter diesen Angular-Decorators gibt es Komponente und Directives, die teils auch in React bzw. Vue existieren, aber auch sogenannte „Pipes“ und „Injectables“, die endemisch für das Angular-Framework sind.

In weiterer Folge ist anzumerken, dass Angular aus der Kiste typensicher ist. TypeScript kann zwar auch mit React und Vue eingesetzt werden, jedoch werden dessen zahlreiche Features nirgends besser genutzt als im Angular. Damit eignet sich dieses Framework für die Entwicklung großer Webapplikationen mit einer komplexen Struktur.

==== Ermittlung der möglichen Backend-Technologien
In diesem Abschnitt werden die drei bekanntesten Backend-Technologien stand 2022 footnote:[Vgl. https://www.statista.com/statistics/1124699/worldwide-developer-survey-most-used-frameworks-web/, abgerufen am 30.10.2022] präsentiert, inklusiv eine moderne vierte Option, die sich sowohl als Frontend- als auch als Backend-Technologie kategorisieren lässt.

===== Express.js
Express ist ein auf Node.js basierendes Web-Framework, das den serverseitigen Teil einer Webapplikation übernimmt. Es wurde von IBM und Strongloop entwicklet und schließlich im Jahr 2010 veröffentlicht. Die drei berühmtesten Tech-Stacks footnote:[Vgl. https://www.fingent.com/blog/top-7-tech-stacks-that-reign-software-development/, aufgerufen am 30.10.2022] in der Webentwicklung – MEAN, MERN und MEVN – basieren alle auf Express.

Mit Express werden Funktionalitäten von Node.js vereinfacht und weitere Features angeboten, wie beispielsweise ein Routing-System oder eine Middleware-Schicht.

Ein weiterer Vorteil von Express ist die Vereinfachung des Entwicklungsprozesses einer REST API. Jedoch ist derselbe Prozess weitaus komplizierter, wenn eine andere API-Architektur bevorzugt wird, wie beispielsweise RPC.

Abschließend ist anzumerken, dass ein Express-Backend auch den Vorteil einer einzigen übergreifenden Programmiersprache bietet. Node.js ist eine serverseitige Laufzeitumgebung für JavaScript und ist der Nutzung des Express-Frameworks vorausgesetzt. Dadurch wird die Komplexität verschiedener Programmiersprachen für den Frontend und Backend reduziert.

===== ASP .NET Core
ASP.NET Core ist ein plattformübergreifendes Framework zum Erstellen von Applikationen, das 2016 von Microsoft als Nachfolger von ASP.NET veröffentlicht wurde. Das Framework ermöglicht nicht nur die Entwicklung von Webapplikationen, sondern auch die Erstellung von Webdiensten, IoT-Apps und mobilen Backends sowie ihre Bereitstellung in der Cloud.

Applikationen, die mit ASP.NET Core entwickelt werden, können eine von drei möglichen Programmiersprachen nutzen: C#, F# und Visual Basic. Die beliebteste von diesen ist C#.

Das Framework bietet eine große Liste an Features footnote:[Vgl. https://learn.microsoft.com/de-ch/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-7.0#why-choose-aspnet-core, abgerufen am 30.10.2022], die es besonders attraktiv machen als Werkzeug zur Entwicklung für Webapplikationen. Erstens bietet es eine einheitliche Umgebung zum Erstellen des UIs sowie der API. Darüber hinaus ist es mit Blazor, einem Framework innerhalb von ASP.NET Core, möglich, C# clientseitig einzusetzen und damit Webbenutzeroberflächen zu erstellen.

===== Django
Django ist ein Web-Framework für die Programmiersprache Python, das 2005 von Django Software Foundation veröffentlicht wurde und von derselben Non-Profit Organisation heutzutage gepflegt wird.

Ein großer Vorteil von Django ist die Möglichkeit, das Datenmodell der Applikation in Python statt in SQL aufzubauen. Dieses Feature wird von Djangos ORM ermöglicht, indem es Datenstrukturen in Python-Klassen übersetzt.footnote:[Vgl. https://www.ibm.com/cloud/learn/django-explained#:~:text=Starting%20a%20Django%20project%20allows,within%20a%20fully%20Python%20environment., abgerufen am 30.11.2022]

In weiterer Folge stellt Django eine CRUD-Funktionalität bereit, womit die Applikation mit der Datenbank direkt gekoppelt wird. Auch bietet das Framework Cross-Site Scripting, Software-Administrierungsfeatures und übernimmt das Management der Nutzer-Sessions. Das letzte Feature ist vor allem für die effiziente Skalierung von Django-Webapplikationen relevant, da es ermöglicht, mehrere Instanzen der Applikation zu erzeugen und die Session-Daten von Benutzern einfach auf neue Instanzen zu transferieren.

Django kann rein als Backend genutzt werden und durch eines der beliebten Frontend-Frameworks ergänzt werden, aber es bietet auch die Möglichkeit, die Django Templating-Sprache für die Erzeugung dynamischer HTML-Inhalte zu nutzen. Diese eignet sich für eine Applikation mit MVC-Architektur besonders gut.

===== Ausnahmefall: Next.js
Next ist ein Ausnahmefall, weil es sowohl eine Frontend- als auch eine Backend-Lösung anbietet. In diesem Sinne ist Next.js ein Full-Stack Framework footnote:[Vgl. https://launchdarkly.com/blog/whats-so-great-about-nextjs/, abgerufen am 30.11.2022]. Es wurde im Jahr 2016 von Vercel Inc. veröffentlicht und wird als ein React-basiertes Web-Framework beschrieben.

Mit Next ist ein React-Frontend und ein Node-Backend vorausgesetzt. Dadurch ist der Vorteil einer einheitlichen Programmiersprache für Frontend und Backend so wie bei Express gegeben. Darüber hinaus bietet das Framework eine große Liste von modernen Features an.

Es gibt drei Arten von Rendering footnote:[Vgl. https://nextjs.org/learn/foundations/how-nextjs-works/rendering, abgerufen am 30.11.2022], die von Next.js unterstützt werden:

•	Client Side Rendering, das standardmäßig von allen anderen Frameworks benutzt wird
•	Server Side Rendering, wo das HTML der Seite für jeden Request auf den Server generiert wird
•	Static Site Generation, wodurch eine Generierung der Seite während dem Build-Prozess der Applikation durchgeführt wird

SSR und SSG sind eine moderne Art des Rendering, das sich „Pre-Rendering“ nennt. Darin wird das Abrufen von Daten und die Transformierung der React-Komponente in HTML vor dem Absenden der Response an den Client durchgeführt.

Next.js bietet nicht nur performante Arten von Rendering, sondern auch eine Lösung zur Authentifizierung durch NextAuth und ein effizientes Routing-System, das aus Dateien und Ordnern automatisch Routen generiert. Das Framework bietet auch Packages zur weiteren Optimierung der Performance, wie „next/image“ und „next/link“.

Zu guter Letzt wird allen Next.js Webapplikationen die Möglichkeit angeboten, die Cloud-Hosting Plattform von Vercel zu nutzen. Das Hosting kommt auch mit einer integrierten CI/CD Pipeline und Edge Functions, Funktionen zur effizienten Lieferung der Seiten-Inhalte vom nächstgelegenen CDN Server. Für Hobby-Projekte ist das Hosting kostenlos.

==== Ermittlung der möglichen API-Architekturen

Es gibt vier bekannte API-Architekturen, die heutzutage eingesetzt werden.footnote:[Vgl. https://www.altexsoft.com/blog/soap-vs-rest-vs-graphql-vs-rpc/, abgerufen am 04.11.2022]

===== RPC
RPC steht für “Remote Procedure Call” und ist ein Kommunikationssystem für Client-Server-basierende Applikationen, das Prozeduren aus anderen Adressräumen aufrufen kann als den Adressraum, in dem die aufrufende Prozedur ausgeführt wird. Dabei findet die Ausführung der Logik einmal am Client, dann am Server und anschließend wieder am Client statt.

Das älteste RPC-Protokoll – XML-RPC – wurde vor SOAP und REST entwickelt, aber mittlerweile gibt es moderne Alternativen. In 2016 veröffentlichte Google ein plattformübergreifendes und höchst performantes RPC-Framework, den sogenannten gRPC. Dieses eignet sich besonders gut für den Einsatz in einer Microservice-Architektur.

Für Node.js und insbesondere in Kombination mit Next.js gibt es ein weiteres Framework, das auch Typensicherheit anbietet. Es nennt sich tRPC und ist ein vitaler Bestandteil des t3-Stacks.footnote:[Vgl. https://create.t3.gg/, abgerufen am 04.11.2022]

===== SOAP
“Simple Object Access Protocol”, oder kurz SOAP, ist ein XML-basiertes Protokoll, das zur Verbreitung der sogenannten „Web Services“ geführt hat. Das XML-Format legt die Struktur der Request- und Response-Nachrichten fest.footnote:[Vgl. https://stoplight.io/api-types/soap-api, abgerufen am 06.11.2022]

Im Hintergrund nutzt SOAP das RPC-Muster, um die Parameter von Funktionen und Methoden zu befüllen und das entsprechende Return-Ergebnis zurückzuliefern. Jedoch waren RPC-Lösungen vor der Einführung auf einer einzigen Programmiersprache limitiert, die von beiden Seiten benutzt werden musste. Mit SOAP wurde eine Entkopplung eingeführt, wodurch die Nutzung verschiedener Programmiersprachen ermöglicht wurde.

Obwohl es immer noch weit verbreitet ist, verliert SOAP in letzter Zeit an Beliebtheit.footnote:[Vgl. https://www.researchgate.net/figure/Trend-of-SOAP-and-REST-in-Google-searches_fig1_296702598, abgerufen am 06.11.2022]

===== REST
REST ist ein Akronym für „Representational State Transfer“ und beschreibt ein Architekturstil für verteilte Hypermedia-Systeme.footnote:[ Vgl. https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm, abgerufen am 06.11.2022] Eine REST-API ist eine API, die sich an den Beschränkungen des REST-Architekturstils halten.

Mit REST wird bei jeder Client-Anfrage die Repräsentation des Ressourcenzustands an einem entsprechenden Endpoint weitergeleitet. Diese Information kann in verschiedenen Formaten übermittelt werden, aber das beliebteste Format ist derzeit JSON. Sobald die Anfrage ankommt wird eine dem Endpoint entsprechende Logik ausgeführt und die erwartete Information im selben Format zurückgeschickt.

Damit eine API „RESTful“ gekennzeichnet werden kann, muss sie folgenden Kriterien erfüllen footnote:[Vgl. https://www.redhat.com/en/topics/api/what-is-a-rest-api, abgerufen am 06.11.2022]:

•	Client-Server-Architektur mit HTTP-Anfragen muss vorhanden sein
•	„Statelessness“, die Trennung von Anfragen, sodass keine Client-Informationen zwischen zwei Anfragen gespeichert werden
•	Cachebare Daten, die Client-Server-Interaktionen vereinfachen
•	Eine Uniforme Schnittstelle damit Informationen in standardisierte Form übermittelt werden
•	Ein hierarchisches System, die jedem Server-Typ richtig einordnet und das für den Client unsichtbar ist

===== GraphQL
GraphQL ist eine Abfragesprache und eine serverseitige Laufzeitumgebung zum Ausführen von Abfragen, die vom damaligen Facebook entwickelt und in 2012 veröffentlicht wurde. 

GraphQL ist Datenbankunabhängig und ermöglicht die Definierung von Typen und von zwei Arten von Abfragen: Mutations und Queries. Mutations sind datenändernde Abfragen wie Create, Update und Delete. Queries hingegen sind Read-Only-Abfragen.

Entwickelt wurde GraphQL als Reaktion auf Probleme, die mit der Nutzung einer REST-API auftauchen. Deswegen ist der größte Vorteil von GraphQL auch das größte Nachteil von REST: Under- und Overfetching. REST-Endpunkte können nur fixe Datenstrukturen zurückliefern, was dazu führt, dass in vielen Fällen entweder zu wenige Daten oder zu viele Daten geliefert werden. Ersteres kann nur mit mehreren Abfragen gelöst werden, während letzteres zwangsläufig mit Leistungsabfälle verbunden ist.

Mit GraphQL ist es möglich, höchst spezifische Abfragen clientseitig zu definieren, ohne dafür serverseitig einen entsprechenden Endpoint aufbauen zu müssen, der diese Abfragen behandelt. GraphQL hat nur einen einzigen Endpoint. Dieser kann mit allen Arten von Abfragen umgehen. Diese Kapazität von GraphQL löst das Problem des Under- und Overfetching.footnote:[Vgl. https://www.howtographql.com/basics/1-graphql-is-the-better-rest/, aufgerufen am 06.11.2022]

Eine GraphQL-API implementiert GraphQL serverseitig und clientseitig. Es gibt bereits mehrere Bibliotheken, die eine vollständige Implementierung bereitstellen, wie beispielsweise Apollo Client/Server.footnote:[Vgl. https://graphql.org/code/, aufgerufen am 06.11.2022]

==== Beurteilungsverfahren
In diesem Abschnitt werden die einzelnen Beurteilungskriterien, die sich aus den bereits genannten Anforderungen ableiten, vorgestellt und erklärt. Im Anschluss daran wird die Beurteilung durchgeführt.

===== Beurteilungskriterien

Zunächst werden die Beurteilungskriterien vorgestellt.

====== Persönliche Erfahrung
Angesichts des großen Ökosystems von Technologien im Bereich der Webentwicklung ist die Auswahl eines geeigneten Stacks in erster Linie von der persönlichen Erfahrung der einzelnen Projektmitglieder abhängig. Die Vertrautheit mit Frameworks steigert die Geschwindigkeit des Entwicklungsprozesses und vermindert die Chancen von Programmfehlern und Bugs. 

Persönliche Erfahrung ist ein großer Vorteil und gilt als wichtigstes Kriterium bei der Auswahl. Daher wird eine Gewichtung von 40% vergeben.

====== Vereinfachung der Komplexität
Frameworks dienen in erster Linie die Aufgabe, den Programmieraufwand zu reduzieren und die Effizienz des Programmierers zu steigern. Je besser ein Frameworks diese Aufgabe erfüllt, desto besser schneidet es auch ab im Vergleich zu anderen Frameworks. Der Programmieraufwand wird generell durch Automatisierung von Prozessen und "Out-of-the-box"-Bereitstellung von Strukturen reduziert. Bei der Steigerung der Effizienz trägt eine intuitive Syntax am meisten bei.

Die Vereinfachung der Komplexität bekommt eine Gewichtung von 25% aufgrund ihrer Wichtigkeit.

====== Modernheit
Es soll eine Applikation entwickelt werden, die nicht schon in den nächsten paar Monaten nach der Entwicklung auf veraltete Technologien basiert. Das ist vor allem deswegen wichtig, weil sich in der Webentwicklung sehr schnell neue Frameworks etablieren. EduCluster benötigt Frameworks und eine API-Architektur, die auf dem neuesten Stand sind und den Test der Zeit bestehen können.

Für die Modernheit wird eine 20%ige-Gewichtung vergeben.

====== Typensicherheit
Die Programmiersprache JavaScript unterstützt keine Typensicherheit, da es lediglich eine interpretierte Sprache ist. Allerdings kann TypeScript diese Anforderung mit seinem Compiler erfüllen. Das würde sowohl den Frontend als auch den Backend individuell typensicher machen. Darüber hinaus soll sichergestellt werden, dass bei der Kommunikation zwischen diesen beiden Seiten kein Missverständnis passiert, weshalb auch die Schnittstellen typensicher sein soll.

Typensicherheit bekommt eine Gewichtung von 10%.

====== Beliebtheit
Beliebte Frameworks haben eine größere Anzahl an Anhänger. Dementsprechend stehen auf Foren wie StackOverflow mehr Fragen und Antworten, die einem bei Schwierigkeiten schnell aushelfen können. Auch wenn eine Frage noch nicht gestellt wurde ist aufgrund der hohen Anzahl an Experten mit einer niedrigen Reaktionszeit zu rechnen. Das ist insofern ein Vorteil, dass die Dokumentation eines Frameworks allein meistens nicht ausreicht um alle Fragen abzudecken, die während der Entwicklung auftauchen.

Diesem Kriterium wird eine Gewichtung von 5% vergeben, da die Anzahl von Fragen großteils schon durch die persönliche Erfahrung der Teammitglieder reduziert werden soll.

===== Überblick der Beurteilungskriterien und deren Gewichtung

TODO: Tabelle aufbauen

===== Beurteilung
Nun sollen die zur Auswahl stehende Möglichkeiten anhand der Beurteilungskriterien bewertet werden. Anschließend wird ein Sieger angekündigt, der bei der technischen Umsetzung benutzt werden soll.

TODO

===== Entscheidung und Begründung der Auswahl
TODO

=== Technische Umsetzung
In diesem Kapitel wird die technische Umsetzung dokumentiert und mithilfe von Screenshots und Diagramme demonstriert.

==== Einleitung
https://create.t3.gg/en/folder-structure
(Sich nach dieser Vorlage und nach der Prinzipien des t3 Stacks halten)

==== Bootstrapping und Konfiguration
https://create.t3.gg/
(Inhalte der Konfigurationsdateien erklären und in Bilder darstellen)

==== Aufbau der API
https://create.t3.gg/en/usage/trpc
https://www.javatpoint.com/spring-boot-architecture
(Architektur erklären und bildlich darstellen)

==== Integration der Untis-Schnittstelle
https://webuntis.noim.me/

=== Reflexion der eigenen Arbeit
In diesem Kapitel wird über die eigene Arbeit reflektiert.

===== Persönlicher Verantwortungsbereich
(Softwarearchitektur planen, Projekt aufsetzen, API aufbauen, Untis Schnittstelle integrieren, Frontend implementieren)

====== Erreichte Ziele
(Was wurde geschafft und funktioniert gut? Was wurde nicht geschafft und warum?)

===== Stundenübersicht
TODO: Tortendiagramm einfügen

===== Persönliches Fazit
TODO

:sectnums!:
